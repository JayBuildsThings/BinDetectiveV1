<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Bin Detective Login</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: { "primary": "#ec1313", "dark": "#221010" },
                    fontFamily: { "display": ["Lexend", "sans-serif"] }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 text-slate-900 font-display min-h-screen flex items-center justify-center p-6">
    <div class="w-full max-w-sm bg-white rounded-3xl p-8 shadow-2xl text-center">
        <div class="w-20 h-20 bg-red-50 text-primary rounded-full flex items-center justify-center mx-auto mb-6">
            <span class="material-symbols-outlined text-4xl">lock</span>
        </div>
        <h2 class="text-2xl font-black mb-2">Secure Sign In</h2>
        <p class="text-gray-500 text-sm mb-6">Use your email and password to continue.</p>
        <div class="flex flex-col gap-3 text-left">
            <input type="email" id="auth-email" placeholder="Email address" autocomplete="email"
                   class="w-full h-12 bg-gray-100 border-none rounded-xl px-4 focus:ring-2 focus:ring-primary">
            <input type="password" id="auth-password" placeholder="Password" autocomplete="current-password"
                   class="w-full h-12 bg-gray-100 border-none rounded-xl px-4 focus:ring-2 focus:ring-primary">
            <input type="text" id="auth-company" placeholder="Company name"
                   class="w-full h-12 bg-gray-100 border-none rounded-xl px-4 focus:ring-2 focus:ring-primary">
        </div>
        <div class="grid grid-cols-2 gap-3 mt-5">
            <button onclick="signIn()" class="w-full h-12 bg-primary text-white font-bold rounded-xl shadow-lg active:scale-95 transition-transform">
                SIGN IN
            </button>
            <button onclick="signUp()" class="w-full h-12 bg-gray-200 text-gray-700 font-bold rounded-xl shadow-lg active:scale-95 transition-transform">
                SIGN UP
            </button>
        </div>
        <button type="button" onclick="requestPasswordReset()" class="mt-4 text-xs font-bold text-gray-400 hover:text-primary transition-colors">
            Forgot password?
        </button>
        <p id="auth-message" class="text-xs text-gray-500 mt-4 min-h-[16px]"></p>
    </div>

    <script>
        const supabaseUrl = 'https://sjpzozgslahdzwqwjtbr.supabase.co';
        const supabaseKey = 'sb_publishable_t01aoRgIetSZ1Fuz0VSrgg_twswmqZV';
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
        const projectRef = new URL(supabaseUrl).hostname.split('.')[0];
        const authStorageKey = `sb-${projectRef}-auth-token`;

        let currentUser = null;
        let currentCompanyId = null;
        let autoLoginInProgress = false;

        function logAuth(message, data = {}) {
            try {
                const entry = { message, data, timestamp: Date.now() };
                const key = 'auth-debug-log';
                const existing = JSON.parse(localStorage.getItem(key) || '[]');
                existing.push(entry);
                localStorage.setItem(key, JSON.stringify(existing.slice(-200)));
            } catch (e) {}
            console.warn('[auth]', message, data);
        }

        function setAuthMessage(message, isError = false) {
            const el = document.getElementById('auth-message');
            if (!el) return;
            el.innerText = message || '';
            el.className = `text-xs mt-4 min-h-[16px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCachedCompanyId() {
            return localStorage.getItem('company-id-cache') || '';
        }

        function setCachedCompanyId(companyId) {
            if (companyId) {
                localStorage.setItem('company-id-cache', companyId);
            }
        }

        async function runWithRetry(label, fn, attempts = 3) {
            let lastError;
            for (let attempt = 1; attempt <= attempts; attempt++) {
                const controller = new AbortController();
                let timeoutId;
                const timeoutPromise = new Promise((_, reject) => {
                    timeoutId = setTimeout(() => {
                        controller.abort();
                        reject({ message: 'Request timed out', code: 'timeout' });
                    }, 8000);
                });
                let data;
                let error;
                try {
                    const result = await Promise.race([fn(controller.signal), timeoutPromise]);
                    data = result?.data;
                    error = result?.error;
                } catch (timeoutError) {
                    error = timeoutError?.name === 'AbortError'
                        ? { message: 'Request timed out', code: 'timeout' }
                        : timeoutError;
                } finally {
                    clearTimeout(timeoutId);
                }
                if (!error) return { data };
                lastError = error;
                logAuth(`${label} attempt ${attempt} failed`, { code: error?.code || null, status: error?.status || null, message: error?.message || '' });
                await sleep(400 * attempt);
            }
            return { error: lastError };
        }

        async function loadCompanyId() {
            logAuth('loadCompanyId start', { hasUser: !!currentUser });
            const res = await runWithRetry('company_users', (signal) => supabase
                .from('company_users')
                .select('company_id')
                .eq('user_id', currentUser.id)
                .maybeSingle()
                .abortSignal(signal));
            const data = res.data;
            const error = res.error;
            if (error) {
                logAuth('company lookup error', { code: error.code || null, status: error.status || null, message: error.message || '' });
            }
            logAuth('loadCompanyId result', { hasData: !!data, hasCompanyId: !!data?.company_id, hasError: !!error });
            if (data?.company_id) {
                currentCompanyId = data.company_id;
                setCachedCompanyId(currentCompanyId);
                logAuth('company cache set', { hasCompanyId: true });
                return true;
            }
            const email = (currentUser?.email || '').trim();
            if (email) {
                const allowedRes = await runWithRetry('allowed_emails_company', (signal) => supabase
                    .from('company_allowed_emails')
                    .select('company_id')
                    .eq('email', email)
                    .maybeSingle()
                    .abortSignal(signal));
                if (allowedRes.error) {
                    logAuth('allowed emails lookup error', { code: allowedRes.error.code || null, status: allowedRes.error.status || null, message: allowedRes.error.message || '' });
                }
                if (allowedRes.data?.company_id) {
                    currentCompanyId = allowedRes.data.company_id;
                    setCachedCompanyId(currentCompanyId);
                    logAuth('company cache set', { hasCompanyId: true, source: 'allowed_emails' });
                    return true;
                }
            }
            const cachedCompanyId = getCachedCompanyId();
            if (cachedCompanyId) {
                currentCompanyId = cachedCompanyId;
                logAuth('company cache used', { hasCompanyId: true });
                return true;
            }
            return false;
        }

        async function ensureCompanyMembership() {
            const companyName = document.getElementById('auth-company').value.trim();
            const email = (currentUser?.email || '').trim();
            logAuth('ensureCompanyMembership start', { hasCompanyName: !!companyName, hasEmail: !!email });
            if (!companyName || !email) {
                setAuthMessage('Enter your company name to continue.', true);
                return false;
            }
            const { error } = await supabase.rpc('claim_company_by_email', {
                p_company_name: companyName,
                p_email: email
            });
            if (error && !String(error.message).toLowerCase().includes('duplicate key')) {
                setAuthMessage(error.message, true);
                logAuth('claim company failed', { code: error.code || null, status: error.status || null, message: error.message || '' });
                return false;
            }
            logAuth('ensureCompanyMembership done', { duplicateOk: !error || String(error.message).toLowerCase().includes('duplicate key') });
            return loadCompanyId();
        }

        async function postAuthInit() {
            if (!currentUser) return;
            logAuth('postAuthInit start', { hasUser: !!currentUser });
            const hasCompany = await loadCompanyId();
            if (!hasCompany) {
                const claimed = await ensureCompanyMembership();
                if (!claimed) {
                    logAuth('postAuthInit blocked', {});
                    return;
                }
            }
            logAuth('postAuthInit redirect', {});
            window.location.href = "manage.html";
        }

        window.signIn = async function() {
            setAuthMessage('');
            const email = document.getElementById('auth-email').value.trim();
            const password = document.getElementById('auth-password').value.trim();
            logAuth('signIn clicked', { hasEmail: !!email, hasPassword: !!password });
            if (!email || !password) {
                setAuthMessage('Email and password are required.', true);
                logAuth('signIn blocked - missing credentials', { hasEmail: !!email, hasPassword: !!password });
                return;
            }
            const { data, error } = await supabase.auth.signInWithPassword({ email, password });
            if (error) {
                setAuthMessage(error.message, true);
                logAuth('signIn error', { code: error.code || null, status: error.status || null, message: error.message || '' });
                return;
            }
            currentUser = data.user;
            logAuth('signIn success', { hasUser: !!currentUser });
            await postAuthInit();
        };

        window.signUp = async function() {
            setAuthMessage('');
            const email = document.getElementById('auth-email').value.trim();
            const password = document.getElementById('auth-password').value.trim();
            if (!email || !password) {
                setAuthMessage('Email and password are required.', true);
                return;
            }
            const { data, error } = await supabase.auth.signUp({
                email,
                password,
                options: {
                    emailRedirectTo: "https://jaybuildsthings.github.io/BinDetectiveV1/login.html"
                }
            });
            if (error) {
                setAuthMessage(error.message, true);
                return;
            }
            if (!data.session) {
                setAuthMessage('Check your email to confirm your account.');
                return;
            }
            currentUser = data.user;
            await postAuthInit();
        };

        window.requestPasswordReset = async function() {
            setAuthMessage('');
            const email = document.getElementById('auth-email').value.trim();
            if (!email) {
                setAuthMessage('Enter your email to reset your password.', true);
                return;
            }
            const { error } = await supabase.auth.resetPasswordForEmail(email, {
                redirectTo: "https://jaybuildsthings.github.io/BinDetectiveV1/set-password.html"
            });
            if (error) {
                setAuthMessage(error.message, true);
                return;
            }
            setAuthMessage('If the email is registered, a password reset link has been sent.');
        };

        async function initExistingSession(trigger) {
            if (autoLoginInProgress) return;
            autoLoginInProgress = true;
            logAuth('initExistingSession start', { trigger });
            const { data, error } = await supabase.auth.getSession();
            if (error) {
                logAuth('getSession error', { code: error.code || null, status: error.status || null, message: error.message || '' });
            }
            if (data.session) {
                currentUser = data.session.user;
                logAuth('initExistingSession found session', { hasUser: !!currentUser });
                await postAuthInit();
            }
            autoLoginInProgress = false;
        }

        supabase.auth.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN' && session) {
                currentUser = session.user;
                initExistingSession('auth_state');
            }
        });

        window.addEventListener('storage', (e) => {
            if (e.key === authStorageKey) {
                initExistingSession('storage');
            }
        });

        initExistingSession('load');
    </script>
</body>
</html>
